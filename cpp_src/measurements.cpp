#include "measurements.h"
#include <stdio.h>
#include <thread>
#include <windows.h>
#define rdtsc __asm __emit 0fh __asm __emit 031h
#define cpuid __asm __emit 0fh __asm __emit 0a2h
// #define CPUID_OVERHEAD_TIME 2528

unsigned cpuid_time = 0;
// unsigned cycles_high1 = 0, cycles_low1 = 0,
// unsigned cycles_high2 = 0, cycles_low2 = 0;
// unsigned __int64 temp_cycles1 = 0, temp_cycles2 = 0;
//__int64 total_cycles = 0;
void measurement_state_init(MeasurementState *state) {
  state->cycles_high1 = 0;
  state->cycles_low1 = 0;
  state->cycles_high2 = 0;
  state->cycles_low2 = 0;
  state->temp_cycles1 = 0;
  state->temp_cycles2 = 0;
  state->total_cycles = 0;
  state->start = 0;
  state->end = 0;
}

// clock_t start, end;

void f() {
  int s = 1;
  for (int i = 0; i < 1000000; ++i) { // Increased from 1000 to 1,000,000
    s += i;
  }
}

void rdtsc_start(MeasurementState *state) {
  if (!state)
    return;
  unsigned int state_ptr = (unsigned int)state;
  __asm {
		pushad
		cpuid
		rdtsc
		mov ebx, state_ptr
		; // mov [ebx]MeasurementState.cycles_high1, edx
		; // mov [ebx]MeasurementState.cycles_low1, eax
		mov [ebx],edx
		mov [ebx+4],eax
		popad
  }
  __asm {
    ; write the assembly instructions to be measured cpuid rdtsc
  }
}

void SetThreadAffinityForCore(int threadIndex) {
  if (threadIndex < 0) {
    printf("Warning: Thread %d: Invalid thread index (negative), falling back "
           "to core 0\n",
           threadIndex);
    SetThreadAffinityMask(GetCurrentThread(), 1);
  }

  unsigned int numCores = std::thread::hardware_concurrency();
  if (threadIndex >= numCores) {
    printf("Warning: Thread %d: Invalid core index %d, max cores: %d, falling "
           "back to core 0\n",
           threadIndex, threadIndex, numCores);
    SetThreadAffinityMask(GetCurrentThread(), 1);
    printf("Thread %d: Failed to set fallback affinity to core 0, error: %lu\n",
           threadIndex, GetLastError());
  }

  DWORD_PTR affinityMask = (1ULL << threadIndex);

  SetThreadAffinityMask(GetCurrentThread(), affinityMask);
}

void compute_cpuid_overhead() {
  unsigned cycles_high1 = 0, cycles_low1 = 0;
  __asm {
		; call the cpuid instruction three times and use the value generated by the 3rd call
		pushad
		cpuid
		rdtsc
		mov cycles_high1, edx
		mov cycles_low1, eax
		popad
		pushad
		cpuid
		rdtsc
		popad

		pushad
		cpuid
		rdtsc
		mov cycles_high1, edx
		mov cycles_low1, eax
		popad
		pushad
		cpuid
		rdtsc
		popad

		pushad
		cpuid
		rdtsc
		mov cycles_high1, edx
		mov cycles_low1, eax
		popad
		pushad
		cpuid
		rdtsc
		sub eax, cycles_low1
		mov cpuid_time, eax
		popad
  }
  cycles_high1 = 0;
  cycles_low1 = 0;
}

MeasuredInfo rdtsc_end(MeasurementState *state,int thread_index_result) {
  if (!state) {
    MeasuredInfo invalid = {0, 0.0,INVALID_MEASUREMENT} ;
    return invalid;
  }

  unsigned int state_ptr = (unsigned int)state;
  __asm {
		pushad
		cpuid
		rdtsc
 		mov ebx, state_ptr
    mov [ebx+8], edx            ; cycles_high2 at offset 8
    mov [ebx+12], eax           ; cycles_low2 at offset 12
		popad
  }
  state->temp_cycles1 =
      ((unsigned __int64)state->cycles_high1 << 32) | state->cycles_low1;
  state->temp_cycles2 =
      ((unsigned __int64)state->cycles_high2 << 32) | state->cycles_low2;
  state->total_cycles = state->temp_cycles2 - state->temp_cycles1 - cpuid_time;

  long long elapsed_cycles = state->total_cycles;
  double elapsed_sec = elapsed_cycles / FREQUENCY;
  // sau double elapsed_sec =
  printf("CPUID overhead = %u\n", cpuid_time);
  printf("Cycles (before) = %llu\n", state->temp_cycles1);
  printf("Cycles (after) = %llu\n", state->temp_cycles2);
  printf("Total cycles = %lld\n", state->total_cycles);

  MeasuredInfo result = {0, 0.0,INVALID_MEASUREMENT};
  result.elapsed_sec = elapsed_sec;
  result.elapsed_cycles = elapsed_cycles;
  result.thread_index=thread_index_result;
  return result;
}

void clock_start(MeasurementState *state) {
  if (state) {
    state->start = clock();
  }
}
MeasuredInfo clock_end(MeasurementState *state,int thread_index_result) {
  if (!state) {
    MeasuredInfo invalid = {0, 0.0,INVALID_MEASUREMENT};
    return invalid;
  }

  state->end = clock();
  double elapsed_sec = (double)(state->end - state->start) / CLOCKS_PER_SEC;
  long long elapsed_cycles = (long long)(elapsed_sec * FREQUENCY);

  MeasuredInfo result = {0, 0.0,INVALID_MEASUREMENT};
  result.elapsed_sec = elapsed_sec;
  result.elapsed_cycles = elapsed_cycles;
  result.thread_index=thread_index_result;
  return result;
}

// int main() {
//   MeasurementState my_state;
//   measurement_state_init(&my_state);
//
//   compute_cpuid_overhead();
//
//   rdtsc_start(&my_state);
//   f();
//   MeasuredInfo info = rdtsc_end(&my_state,1);
//
//   MeasurementState my_state2;
//   measurement_state_init(&my_state2);
//   clock_start(&my_state2);
//   f();
//   MeasuredInfo info2 = clock_end(&my_state2,2);
//   printf("Measurement: %lld cycles\n", info2.elapsed_cycles);
//   printf("Measurement: %f seconds\n", info2.elapsed_sec);
//
//   return 0;
// }
